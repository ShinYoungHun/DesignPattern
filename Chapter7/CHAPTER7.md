어댑터 패턴(Adapter Pattern)
- 객체 어댑터
- 특정 클래스 인터페이스를 클라이언트에서 요구하는 다른 인터페이스로 변환
- 인터페이스가 호환되지 않아 같이 쓸 수 없었던 클래스를 사용할 수 있게 도움
- 메소드가 일대일로 대응되지 않는 상황에서는 어댑터를 완벽하게 적용할 수 없다

``` mermaid
---
title: Adapter
---
classDiagram
    direction LR
    Client --> Target
    Adapter ..> Target
    Adapter --> Adaptee : 어댑터는 어댑티로 구성

note for Client "Client는 Target 인터페이스만 볼 수 있음"
class Client{
 
}

class Target{
    <<interface>>
    request()
}

note for Adapter "어댑터에서 타깃 인터페이스를 구현"
class Adapter{
    request()
}

note for Adaptee "모든 요청은 어댑티에 위임"
class Adaptee{
    specificRequest()
}
```

- 퍼사드 패턴(facade Pattern)
 - 인터페이스를 단순하게 만들고 클라이언트와 구성 요소로 이루어진 서브시스템을 분리하는 역할
 - 서브시스템에 있는 일련의 인터페이스를 통합 인터페이스로 묶음
 - 고수준 인터페이스도 정의하므로 서브시스템을 더 편리하게 사용할 수 있음

 - 퍼사드와 어댑터는 모두 여러 개의 클래스를 감쌀 수 있다
 - 퍼사드는 인터페이스를 단순하게 만드는 용도
 - 어댑터는 인터페이스를 다른 인터페이스를 변환하는 용도
 
```
 - 디자인 원칙
 최소 지식 원칙(Principle of Least Knowledge)
 객체 사이의 상호작용은 될 수 있으면 아주 가까운 '친구' 사이에서만 허용
```
- 장점
    - 객체 사이의 의존성을 줄임 및 소프트웨어 관리가 편해짐    
- 단점
    - 메소드 호출을 처리하는 '래퍼' 클래스를 더 만들어야함
    - 시스템이 복잡해지고, 개발 시간도 늘어나고, 성능도 떨어짐

- 핵심정리
    - 기존 클래스를 사용하려고 하는데 인터페이스가 맞지 않으면 어댑터를 쓰면 됨
    - 큰 인터페이스와 여러 인터페이스를 단순하게 바꾸거나 통합해야 하면 퍼사드를 쓰면 됨
    - 어댑터는 인터페이스를 클라이언트에서 원하는 인터페이스로 바꾸는 역할을 함
    - 퍼사드는 클라이언트를 복잡한 서브시스템과 분리하는 역할을 함
    - 어댑터를 구현할 때는 타깃 인터페이스의 크기와 구조에 따라 코딩해야 할 분량이 결정됨
    - 퍼사드 패턴에서는 서브시스템으로 퍼사드를 만들고 진짜 작업은 서브클래스에 맡김
    - 어댑터 패턴에는 객체 어댑터 패턴과 클래스 어댑터 패턴이 있다
    - 클래스 어댑터를 쓰려면 다중 상속이 가능해야 함(JAVA 불가)
    - 한 서브시스템에 퍼사드를 여러개 만들어도 됨
    - 어댑터는 객체를 감싸서 인터페이스를 바꾸는 용도로    
    데코레이터는 객체를 감싸서 새로운 행동을 추가하는 용도로    
    퍼사드는 일련의 객체를 감싸서 단순하게 만드는 용도로 사용